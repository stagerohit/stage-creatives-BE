import { Injectable, HttpException, HttpStatus } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { v4 as uuidv4 } from 'uuid';
import * as fs from 'fs';
import * as path from 'path';
import { GoogleGenAI, Modality } from '@google/genai';

import { TitleLogo, TitleLogoDocument } from '../schemas/title-logo.schema';
import { Content, ContentDocument } from '../../content/content.schema';
import { CreateTitleLogoDto } from '../dto/create-title-logo.dto';

/**
 * Title Logo Service for Gemini Imagen API integration
 * 
 * Generates movie title logos using Google's Gemini Imagen model
 */
@Injectable()
export class TitleLogoService {
  private readonly genAI: GoogleGenAI;
  private readonly uploadsPath = path.join(process.cwd(), 'uploads', 'title-logos');

  constructor(
    @InjectModel(TitleLogo.name) private titleLogoModel: Model<TitleLogoDocument>,
    @InjectModel(Content.name) private contentModel: Model<ContentDocument>,
  ) {
    // Initialize Google GenAI with API key
    this.genAI = new GoogleGenAI({
      apiKey: 'AIzaSyBVbV_ytZH2kH2BizetHb7gl2SFJymGVE0'
    });

    // Ensure uploads directory exists
    if (!fs.existsSync(this.uploadsPath)) {
      fs.mkdirSync(this.uploadsPath, { recursive: true });
    }
  }

  async generateTitleLogo(createTitleLogoDto: CreateTitleLogoDto): Promise<TitleLogo> {
    console.log('üéØ TitleLogo Service - generateTitleLogo called');
    const { content_id, slug, title_prompt, channel, dimension } = createTitleLogoDto;
    console.log('üìä Input params:', { content_id, slug, title_prompt, channel, dimension });

    try {
      console.log('üîç Step 1: Validating content and fetching title...');
      // Step 1: Validate content_id and fetch title
      const content = await this.validateAndFetchContent(content_id);
      console.log('‚úÖ Content found:', { title: content.title, content_id: content.content_id });
      
      console.log('üé® Step 2: Generating image with Gemini Imagen...');
      // Step 2: Generate image using Gemini Imagen API
      const generatedImagePath = await this.callGeminiImagenAPI(content.title, title_prompt, dimension);
      console.log('‚úÖ Image generated and saved:', generatedImagePath);
      
      console.log('üìù Step 3: Creating database record...');
      // Step 3: Create TitleLogo record in database
      const titleLogo = new this.titleLogoModel({
        title_logo_id: uuidv4(),
        content_id,
        slug,
        title_logo_url: generatedImagePath,
        channel,
        title_prompt,
        title: content.title,
        dimension,
      });

      const savedRecord = await titleLogo.save();
      console.log('‚úÖ Title logo record saved with ID:', savedRecord.title_logo_id);
      return savedRecord;
    } catch (error) {
      console.error('‚ùå Error in generateTitleLogo service:', error.message);
      console.error('üîç Full error:', error);
      throw new HttpException(
        error.message || 'Failed to generate title logo',
        error.status || HttpStatus.INTERNAL_SERVER_ERROR,
      );
    }
  }

  private async validateAndFetchContent(content_id: string): Promise<ContentDocument> {
    const content = await this.contentModel.findOne({ content_id }).exec();
    if (!content) {
      throw new HttpException(`Content with ID ${content_id} not found`, HttpStatus.NOT_FOUND);
    }
    if (!content.title) {
      throw new HttpException(`Content with ID ${content_id} has no title`, HttpStatus.BAD_REQUEST);
    }
    return content;
  }

  private async callGeminiImagenAPI(title: string, title_prompt: string, dimension?: string): Promise<string> {
    try {
      console.log('ü§ñ Calling Gemini 2.0 Flash Image Generation API...');
      
      // Build the final prompt
      const finalPrompt = `Movie Title is "${title}". ${title_prompt} Write the Movie Title in english in a cinematic style, capturing the theme of the movie. The output image should have a transparent background`;
      console.log('üìù Final prompt:', finalPrompt);

      // Call Gemini 2.0 Flash API with correct method
      const response = await this.genAI.models.generateContent({
        model: 'gemini-2.0-flash-preview-image-generation',
        contents: finalPrompt,
        config: {
          responseModalities: [Modality.TEXT, Modality.IMAGE],
        },
      });

      console.log('‚úÖ Gemini API response received');
      
      if (!response.candidates || response.candidates.length === 0) {
        throw new Error('No candidates generated by Gemini API');
      }

      // Process the response parts to find the image
      const candidate = response.candidates[0];
      if (!candidate?.content?.parts) {
        throw new Error('No content parts received from Gemini API');
      }

      const parts = candidate.content.parts;
      let imageData: string | null = null;

      for (const part of parts) {
        if (part.text) {
          console.log('üìù Gemini response text:', part.text);
        } else if (part.inlineData?.data) {
          imageData = part.inlineData.data;
          console.log('üñºÔ∏è Image data received from Gemini');
          break;
        }
      }

      if (!imageData) {
        throw new Error('No image data received from Gemini API');
      }

      // Save the image
      const savedPath = await this.saveImageFromBase64(imageData);
      console.log('‚úÖ Image saved successfully:', savedPath);
      
      return savedPath;
    } catch (error) {
      console.error('‚ùå Gemini API call failed:', error);
      throw new HttpException(
        `Gemini API failed: ${error.message}`,
        HttpStatus.SERVICE_UNAVAILABLE,
      );
    }
  }



  private async saveImageFromBase64(base64Data: string): Promise<string> {
    try {
      // Decode base64 to buffer
      const imageBuffer = Buffer.from(base64Data, 'base64');
      
      // Generate unique filename
      const filename = `${uuidv4()}.png`;
      const filePath = path.join(this.uploadsPath, filename);
      
      // Save image to uploads folder
      fs.writeFileSync(filePath, imageBuffer);
      
      // Return relative path for database storage
      return `/uploads/title-logos/${filename}`;
    } catch (error) {
      console.error('Error saving image from base64:', error);
      throw new HttpException('Failed to save generated image', HttpStatus.INTERNAL_SERVER_ERROR);
    }
  }

  async getTitleLogoById(title_logo_id: string): Promise<TitleLogo> {
    const titleLogo = await this.titleLogoModel.findOne({ title_logo_id }).exec();
    if (!titleLogo) {
      throw new HttpException('Title logo not found', HttpStatus.NOT_FOUND);
    }
    return titleLogo;
  }

  async getTitleLogosByContentId(content_id: string): Promise<TitleLogo[]> {
    return await this.titleLogoModel.find({ content_id }).exec();
  }

  async getAllTitleLogos(query: any): Promise<{
    data: TitleLogo[];
    total: number;
    page: number;
    limit: number;
  }> {
    const { page = 1, limit = 10, sort = 'created_at', order = 'desc', ...filters } = query;
    
    // Build filter object
    const filterObj: any = {};
    if (filters.content_id) filterObj.content_id = filters.content_id;
    if (filters.slug) filterObj.slug = new RegExp(filters.slug, 'i');
    if (filters.channel) filterObj.channel = filters.channel;
    if (filters.dimension) filterObj.dimension = filters.dimension;

    // Calculate pagination
    const skip = (page - 1) * limit;
    const sortObj: any = { [sort]: order === 'desc' ? -1 : 1 };

    // Execute queries
    const [data, total] = await Promise.all([
      this.titleLogoModel.find(filterObj).sort(sortObj).skip(skip).limit(limit).exec(),
      this.titleLogoModel.countDocuments(filterObj).exec(),
    ]);

    return {
      data,
      total,
      page,
      limit,
    };
  }
} 