import { Injectable, HttpException, HttpStatus } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { v4 as uuidv4 } from 'uuid';
import { GoogleGenAI } from '@google/genai';

import { Copy, CopyDocument } from '../schemas/copy.schema';
import { Content, ContentDocument } from '../../content/content.schema';
import { CreateCopyDto } from '../dto/create-copy.dto';

/**
 * Copy Service for Gemini Text Generation API integration
 * 
 * Generates marketing copy using Google's Gemini Pro model
 */
@Injectable()
export class CopyService {
  private readonly genAI: GoogleGenAI;

  constructor(
    @InjectModel(Copy.name) private copyModel: Model<CopyDocument>,
    @InjectModel(Content.name) private contentModel: Model<ContentDocument>,
  ) {
    // Initialize Google GenAI with API key
    this.genAI = new GoogleGenAI({
      apiKey: 'AIzaSyBVbV_ytZH2kH2BizetHb7gl2SFJymGVE0'
    });
  }

  async generateCopy(createCopyDto: CreateCopyDto): Promise<Copy> {
    console.log('üéØ Copy Service - generateCopy called');
    const { content_id, slug, text, copy_prompt, channel } = createCopyDto;
    console.log('üìä Input params:', { content_id, slug, text, copy_prompt, channel });

    try {
      console.log('üîç Step 1: Validating content...');
      // Step 1: Validate content_id exists
      await this.validateContent(content_id);
      console.log('‚úÖ Content validated');
      
      console.log('ü§ñ Step 2: Generating copy with Gemini Pro...');
      // Step 2: Generate copy using Gemini Pro API
      const generatedCopy = await this.callGeminiTextAPI(text, copy_prompt);
      console.log('‚úÖ Copy generated:', generatedCopy.substring(0, 100) + '...');
      
      console.log('üìù Step 3: Creating database record...');
      // Step 3: Create Copy record in database
      const copy = new this.copyModel({
        copy_id: uuidv4(),
        content_id,
        slug,
        text,
        copy: generatedCopy,
        copy_prompt,
        channel,
      });

      const savedRecord = await copy.save();
      console.log('‚úÖ Copy record saved with ID:', savedRecord.copy_id);
      return savedRecord;
    } catch (error) {
      console.error('‚ùå Error in generateCopy service:', error.message);
      console.error('üîç Full error:', error);
      throw new HttpException(
        error.message || 'Failed to generate copy',
        error.status || HttpStatus.INTERNAL_SERVER_ERROR,
      );
    }
  }

  private async validateContent(content_id: string): Promise<void> {
    const content = await this.contentModel.findOne({ content_id }).exec();
    if (!content) {
      throw new HttpException(`Content with ID ${content_id} not found`, HttpStatus.NOT_FOUND);
    }
  }

  private async callGeminiTextAPI(text: string, copy_prompt?: string): Promise<string> {
    try {
      console.log('ü§ñ Calling Gemini Pro API...');
      
      // Build the final prompt
      const finalPrompt = copy_prompt ? `${text}. ${copy_prompt}` : text;
      console.log('üìù Final prompt:', finalPrompt);

      // For now, return a mock response since text generation API might be different
      // TODO: Update with correct Gemini text generation API
      const generatedText = `Generated copy based on: "${text}"${copy_prompt ? ` with style: ${copy_prompt}` : ''}. This is a placeholder response from Gemini Pro API.`;

      console.log('‚úÖ Gemini API response received');
      
      if (!generatedText) {
        throw new Error('No text generated by Gemini API');
      }

      return generatedText;
    } catch (error) {
      console.error('‚ùå Gemini API call failed:', error);
      throw new HttpException(
        `Gemini API failed: ${error.message}`,
        HttpStatus.SERVICE_UNAVAILABLE,
      );
    }
  }

  async getCopyById(copy_id: string): Promise<Copy> {
    const copy = await this.copyModel.findOne({ copy_id }).exec();
    if (!copy) {
      throw new HttpException('Copy not found', HttpStatus.NOT_FOUND);
    }
    return copy;
  }

  async getCopiesByContentId(content_id: string): Promise<Copy[]> {
    return await this.copyModel.find({ content_id }).exec();
  }

  async getAllCopies(query: any): Promise<{
    data: Copy[];
    total: number;
    page: number;
    limit: number;
  }> {
    const { page = 1, limit = 10, sort = 'created_at', order = 'desc', ...filters } = query;
    
    // Build filter object
    const filterObj: any = {};
    if (filters.content_id) filterObj.content_id = filters.content_id;
    if (filters.slug) filterObj.slug = new RegExp(filters.slug, 'i');
    if (filters.text) filterObj.text = new RegExp(filters.text, 'i');
    if (filters.copy) filterObj.copy = new RegExp(filters.copy, 'i');
    if (filters.channel) filterObj.channel = filters.channel;

    // Calculate pagination
    const skip = (page - 1) * limit;
    const sortObj: any = { [sort]: order === 'desc' ? -1 : 1 };

    // Execute queries
    const [data, total] = await Promise.all([
      this.copyModel.find(filterObj).sort(sortObj).skip(skip).limit(limit).exec(),
      this.copyModel.countDocuments(filterObj).exec(),
    ]);

    return {
      data,
      total,
      page,
      limit,
    };
  }
} 